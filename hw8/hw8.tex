% CS457 HW8

\documentclass{article}
\usepackage{anysize}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}

\marginsize{2cm}{2cm}{2cm}{2cm}

\title{CS457 Functional Programming\\
Mark Jones Winter 2012\\
Homework 8}
\author{Russell Miller}
\date{\today}

\begin{document}

\maketitle

\section*{QUESTION 1}
\textbf{Prove the following law holds for all \lstinline{f, e, and g.}}
\lstset{language=Haskell, mathescape=true, basicstyle=\ttfamily}
\begin{lstlisting}
  foldr f e . map g = foldr (f . g) e
\end{lstlisting}

\noindent I'm going to rewrite this law using a variable xs to represent the
list argument for each side. We'll say that this law is P(xs).
\begin{lstlisting}
  P(xs) = (foldr f e . map g) xs = (foldr (f . g) e) xs
\end{lstlisting}

\noindent Similar to the proof we did in class, we will need to prove 3 cases:
\lstinline{P([]), P($\bot$), and P(xs) $\Rightarrow$ P(x:xs)},\\
where $\bot$ is execution that does not
terminate properly.\\
\\
First we need the definition of \lstinline{foldr}:
\begin{lstlisting}
  foldr f z []     = z                   (foldr.0)
  foldr f z (x:xs) = f x (foldr f z xs)  (foldr.1)
\end{lstlisting}

\rm (found in the Prelude using Hugs's \lstinline{:f} command.)\\
\\
The definition of map we defined in class.
\begin{lstlisting}
  map f []           = []                 (map.0)
  map f (x:xs)       = f x : map f xs     (map.1)
\end{lstlisting}

\noindent Great! \lstinline{foldr} and \lstinline{map} are defined for 
\lstinline{[]} and \lstinline{x:xs}. Now we need to come up with laws about 
\lstinline{map} and \lstinline{foldr} for the case of $\bot$.\\
\\
In class we talked about \lstinline{map f $\bot$}.
\begin{lstlisting}
  map f $\bot$       = $\bot$ (map.$\bot$)
\end{lstlisting}

\noindent By looking at the definition of \tt foldr\rm, it is clear that it will work the same.
It does something to each element of a list, and recursively works through the list
the same way map does just that.
Thus:
\begin{lstlisting}
  foldr f z $\bot$   = $\bot$ (foldr.$\bot$)
\end{lstlisting}

\noindent Now we're ready to prove the property for the 3 cases talked about earlier.\\

\pagebreak

\indent \lstinline{P([])}:\\
We want to show that\\ \lstinline{  (foldr f e . map g) [] = foldr (f . g) e []}
\begin{lstlisting}
LHS = (foldr f e . map g) []
    = foldr f e (map g [])               {definition of .}
    = foldr f e []                       {by map.0}
    = e                                  {by foldr.0}
RHS = foldr (f . g) e []
    = e                                  {by foldr.0}
\end{lstlisting}

% this one looks like the validations are further, but it's cause of $\bot$

\indent \lstinline{P($\bot$)}:\\
We want to show that\\ 
\lstinline{  (foldr f e . map g) $\bot$ = foldr (f . g) e $\bot$}
\begin{lstlisting}
LHS = (foldr f e . map g) $\bot$
    = foldr f e (map g $\bot$)                 {definition of .}
    = foldr f e $\bot$                         {by map.$\bot$}
    = $\bot$                                   {by foldr.$\bot$}
RHS = foldr (f . g) e $\bot$
    = $\bot$                                   {by foldr.$\bot$}
\end{lstlisting}

\indent \lstinline{P(xs) $\Rightarrow$ P(x:xs)}:\\
We want to show that\\
\lstinline{  (foldr f e . map g) (x:xs)    = foldr (f . g) e (x:xs)}
\begin{lstlisting}
LHS = (foldr f e . map g) (x:xs)
    = foldr f e (map g (x:xs))           {definition of .}
    = foldr f e (g x : map g xs)         {by map.1}
    = f (g x) (foldr f e (map g xs))     {by foldr.1}
RHS = foldr (f . g) e (x:xs)
    = (f . g) x (foldr (f . g) e xs)     {by foldr.1}
    = (f . g) x ((foldr f e . map g) xs) {induction, P(xs)}
    = f (g x) (foldr f e (map g xs))     {definition of .}
\end{lstlisting}
$\blacksquare$

\end{document}
